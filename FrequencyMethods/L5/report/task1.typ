#let image200 = image.with(width: 200mm)

Рассмотрим прямоугольную функцию $Pi: RR -> RR$:
$
  Pi(t) = cases(
    1", " |t| <= 1/2,
    0", " |t| > 1/2,
  )
$

Ее истинным фурье-образов является интеграл:
$
  hat(Pi) (nu) = integral_(-oo)^oo Pi(t) e^(-2pi i nu t) dif t
$

Вычислим значение интеграла:
$
  integral_(-oo)^oo Pi(t) e^(-2pi i nu t) dif t =
  integral_(-1/2)^(1/2)1 dot e^(-2pi i nu t) dif t = \ =
  integral_(-1/2)^(1/2) e^(-2pi i nu t) 1/(-2pi i nu) dif (-2pi i nu t) =
  1/(-2pi i nu) lr(e^(-2pi i nu t) ""/""|)_(t=-1/2)^(t=1/2) = \ =
  (e^(-pi i nu)-e^(pi i nu))/(-2pi i nu) =
  ( cos(pi nu) - i sin(pi nu) - cos(pi nu) - i sin(pi nu) )/( -2pi i nu ) = \ =
  (-2 i sin(pi nu))/(-2pi i nu) =sin(pi nu)/(pi nu) = #box(stroke: 1pt, inset: .5em, outset: .1em, baseline: 25%)[$sinc(pi nu)$]
$

Построим графики функции и ее образа, полученного аналитическим путем:

#figure(
  image200("../fig/task1/1.0/f.png"),
  caption: [График функции $Pi(t)$]
)

#figure(
  image200("../fig/task1/1.0/F_hat.png"),
  caption: [График аналитического образа функции $hat(Pi)(t)$]
)




= Численное интегрирование
Найдем спектр функции $Pi(t)$ и затем восстановим функцию из него, используя
численный метод интегрирования
#text(font: "DejaVu Sans Mono", size: 12pt)[nympy.trapezoid]:

Построим графики результатов при разных парах значений $T$ и $dif t$:


// (2, 0.005, 10, 0.05),
// (5, 0.005, 60, 0.05),  # small T
// (2, 0.05, 10, 0.5),  # small V  -> recon smoother
// (5, 0.05, 60, 0.5),  # large dt -> ft repeants & recon wrong

#let T = (2,5,2,5)
#let dt_ = (0.005, .005, .05, .05)
#let V = (10,60,10,60)
#let dv_ = (.05,.05,.5,.5)
#for idx in (0,1,2,3) {
  figure(
    image200("../fig/task1/1.1/{}/F.png".replace("{}",str(idx))),
    caption: [Образ $hat(Pi)(t)$ полученный численным интегрированием \ при
      $T=#T.at(idx)$ $dif t = #dt_.at(idx)$ $V=#V.at(idx)$ $dif nu = #dv_.at(idx)$]
  )

  figure(
    image200("../fig/task1/1.1/{}/F_recon.png".replace("{}",str(idx))),
    caption: [Восстановленный из спектра сигнал методом числ. интегрирования \ при
    $T=#T.at(idx)$ $dif t = #dt_.at(idx)$ $V=#V.at(idx)$ $dif nu = #dv_.at(idx)$]
  )
}

== Выводы
- Метод достаточно точно приближает аналитический спектр функции.
- При восстановлении сигнала появляются искажения, связанные с
  разрывами в сигнале.
- При слишком маленьком $dif nu$ в спектре сигнала появляется периодичность.

= Использование DFT

Классическое унитарное DFT дискретного сигнала $x_k$ вычисляется следующим образом:
$
  X[k] = 1/sqrt(N) sum_(n=0)^(N-1) x[n] e^(-2pi i n k \/ N)
$
Обратное:
$
  x[k] = 1/sqrt(N) sum_(n=0)^(N-1) X[n] e^(2pi i n k \/ N)
$

Воспользуемся реализацией, которая есть в пакете numpy.

В случае с DFT параметрами которые мы можем менять являются только
$T$ и $dif t$, а величины $V$ и $dif nu$ зависят от параметров $T$ и $dif t$ следующим
образом:

#let dt = $dif t$
#let dv = $dif nu$
$
dv = 1/dt dot 1 / N = 1 / (dt N) = 1 / (dt dot (T/dt)) = 1/T
$

$
V = 1/dt
$

== Графики
Построим графики DFT сигнала $Pi(t)$ с различными парами параметров $T$ и $dt$
и соответствующим им $V$ и $dv$.

// (4, 0.005),
// (4, 0.05),  # big dt -> small V
// (8, 0.005),  # big T -> small dv

#let T = (4,4,8)
#let dt_ = (0.005, .05, .005)
#let V = (200, 20, 200)
#let dv_ = (0.25,0.25,0.125)

#for idx in (0,1,2) {
  figure(
    image200("../fig/task1/1.2/{}/F.png".replace("{}",str(idx))),
    caption: [DFT сигнала $Pi(t)$ и $sinc(nu)$\ при
      $T=#T.at(idx)$ $dif t = #dt_.at(idx)$ $V=#V.at(idx)$ $dif nu = #dv_.at(idx)$]
  )

  figure(
    image200("../fig/task1/1.2/{}/F_recon.png".replace("{}",str(idx))),
    caption: [Обратное DFT сигнала $hat(Pi)(nu)$ \ при
    $T=#T.at(idx)$ $dif t = #dt_.at(idx)$ $V=#V.at(idx)$ $dif nu = #dv_.at(idx)$]
  )
}

== Выводы
- FFT выполняется на несколько порядков быстрее, чем метод численного
  интегрирования.
- Сигнал восстанавливается из спектра точнее, чем при использовании численного
  интегрирования.
- При увеличении временного окна $T$ разрешение спектра $dv$ увеличивается
  имея зависимость $dv = 1\/T$.
- При уменьшении dt ширина спектра увеличивается
  имея зависимость $V = 1\/dt$

= Сравнение методов

Численное интегрирование приблизительно вычисляет значения интегралов
преобразования Фурье:

#set math.equation(numbering: "(1)")

$
  hat(f)(nu) = integral_(-T\/2)^(T\/2) f(t) e^(-2pi i nu t) dt approx
  sum_(n=0)^(N-1) f(t_n) e^(-2pi i nu t_n) Delta t
$ <fair>

Метод DFT вычисляет следующую сумму:

$
  hat(f)_k = 1/sqrt(N) sum_(n-0)^(N-1)f_n e^(2pi i (k n)/N) \
  f_n = 1/sqrt(N) sum_(k=0)^(N-1) hat(f)_k e^(2pi i (k n)/N)
$

#quote[Честное] интегрирование по @fair[Формуле] работает заметно дольше
алгоритма FFT и имеет Сложность $O(M N) tilde O(N^2)$, в то время как
FFT применяет несколько оптимизаций и выполняется за $O(N log N)$.

Если сравнить скорость работы алгоритмов которые использовались для получения
данных для рисунков выше, видно, что FFT работает на порядок быстрее:

#show figure.where(kind: table): set figure.caption(position: top)
#figure(
  table(columns: 3, align: center+horizon,
  [N],[Приближение интегралов],[ FFT ],
  [1000],[ 26.8528 мс ],[ 0.1009 мс ],
  [2000],[ 91.3551 мс ],[ 0.1142 мс ],
  [10000],[ 2675.1659 мс  ],[ 0.3968 мс ],
  ),
  caption: [Сравнение времени исполнения разных алгоритмов\ преобразования Фурье]
)

В это время метод трапеций производит относительно точный спектр,
но нужно учитывать что при численном интегрировании накапливается ошибка,
а при обратном преобразовании эта ошибка будет ещё больше из-за двойного
интегрирования.

Метод FFT пользуется дискретностью сигнала и приминение пары обратных операций
DFT/IDFT возвращают исходный сигнал. Но спектр, полученный при помощи FFT не
совпадает с истинным спектром, так как оно привязяно к дискретности исходного сигнала.

Справедливо разграничить области применения численного интегрирования и FFT:
первый стоит использовать для оценки непрервыного преобразования, а FFT для
обработки сигнала --- его фильтрации или анализа.



= Приближение непрерывного преобразования c помощью FFT

Попробуем приблизить результат DFT к истинному спектру сигнала:

Пусть $f(t): [-T\/2, T\/2] -> RR$.

$
  hat(f)(nu_m) = integral_(-T\/2)^(T\/2) f(t) e^(-2pi i nu_m t) dt, nu_m = m/T, m = 0,1..N-1
$
$
  hat(f)(nu_m) approx sum_(n=0)^(N-1) f(t_n) e^(-2pi i nu_m t_n) Delta t,
  "где " t_n = -T/2 + n Delta t
$

так как $v_m = m/T$:

$
  e^(-2pi i nu_m t_n) = e^(-2pi i m/T (-T/2+n Delta t))
  = e^(i pi m) e^(-2pi i (m n)/N) = (-1)^m e^(-2pi i (m n)/N)
$

Получили:

$
  hat(f)(nu_m) approx Delta t (-1)^(m)
  underbrace(sum_(n=0)^(N-1) f_n e^(-2pi i (m n)/N), op("FFT")(f))
$

Обозначим $Delta t  e^(2pi i m) = Delta t (-1)^m = c_m$

В коеффициенте $c_m$ $Delta t$ отвечает за масштабирование сигнала,
а $e^(2 pi i m) = e^(-2pi i T/2)$ за фазу, учитая начальное время сигнала $t_0 = -T/2$

== Релизация метода
+ Имеем дискретизированную функцию $f_n$,
  отсчеты по которой взяты по временному окну шириной $T$ с шагом $dt$.
+ Вычисляем DFT сигнала при помощи FFT и сдвигаем нуль в центр:
  $
    F = op("fftshift")(op("FFT"){f_n})
  $
+ Домножаем спектр на коеффициент масштабирования:
  $
    F_"умное" = c_m dot F
  $
+ Восстановление сигнала в обратном порядке:
  $
    f_"восст" = op("ifft") (op("ifftshift"){ F_"умное" \/ c_m })
  $

Сравним спектры и восстановленный сигнала тремя известными методами при
различный парах параметров $T$ и $dt$ и соответствующих им $V$ $dv$:

#let T = (4,4,8)
#let dt_ = (0.004, 0.08, 0.004)
#let V = (250, 125, 250)
#let dv_ = (0.25, 0.25, 0.125)
#for idx in (0,1,2) {
  figure(
    image200("../fig/task1/1.4/new_method/{}/F.png".replace("{}",str(idx))),
    caption: [#quote[умное] DFT сигнала $Pi(t)$ \ при
      $T=#T.at(idx)$ $dif t = #dt_.at(idx)$ $V=#V.at(idx)$ $dif nu = #dv_.at(idx)$]
  )

  figure(
    image200("../fig/task1/1.4/new_method/{}/recon.png".replace("{}",str(idx))),
    caption: [Обратное #quote[умное] DFT сигнала $hat(Pi)(nu)$ \ при
    $T=#T.at(idx)$ $dif t = #dt_.at(idx)$ $V=#V.at(idx)$ $dif nu = #dv_.at(idx)$]
  )
}

#for idx in (0,1,2) {
  figure(
    image200("../fig/task1/1.4/F_comp/{}.png".replace("{}",str(idx))),
    caption: [Сранение спектров #quote[ умного ] DFT, DFT и численного интегрирования]
  )
}

#for idx in (0,1,2) {
  figure(
    image200("../fig/task1/1.4/recon_comp/{}.png".replace("{}",str(idx))),
    caption: [Сранение восстановленного сигнала через #quote[ умного ] DFT, DFT и численного интегрирования]
  )
}

== Выводы
- Умножение на $c_m$ компенсирует сдвиг по фазе, а $Delta t$ масштабирование спектра сигнала.
- Полученный метод сочетает скорость алгоритма FFT и точность численного
  интегрирвования.
- Спектр, полученный новым методом совпадает со спектром, полученным аналитическим
  образом.
- Восстановление сигнала полученным метод даёт возвращает исходный сигнал,
  в отличие от метода численного интегрирования, в котором накапливается ошибка
  при интегрировании.
- Величины при использовании нового метода $V$ и $dif v$ зависят от параметров
  $T$ и $dif t$ таким же образом, как и при использовании классического DFT.
