#import "style.typ": *
#import "titlepage.typ": TitlePage

#let image200 = image.with(width: 200mm)

#show: ReportStyle.with(
  [Лабораторная работа № 4. \ Линейная фильтрация],
  (
    name: [Смирнов Алексей Владимирович],
    group: [R3242],
    isu: [409578]
  ),
  (
    university: [Университет ИТМО],
    city: [г. Санкт-Петербург],
    faculty: [Факультет СУиР]
  )
)

= Задание 1. Линейные фильтры.

Рассмотрим сигнал $g(t)$:
$
  g(t) = cases(
    a", "t in [1,2],
    0", "t in.not [1,2]
  )
$
и его зашумленную версию:
$
 u(t) = g(t) + b xi(t) + c sin(d t) 
$
где $xi(t) ~ cal(U)[-1,1]$, а значения $b,c,d$ - параметры возмущения.

== Фильтр первого порядка

Приняли $c=0$. Зададим некую постоянную $T$ и пропустим сигнал через фильтр первого
порядка 
$
  W_1(p) = 1 / (T p + 1)
$

// === Вариация параметра $T$

Исследуем на что влияет параметр $T$

#for (N, T) in (0, 1, 2).zip((0.001, 0.01, 0.1)) [
  $T = #T$
  #figure(
    image200("../fig/1/1/T/fr/{}.png".replace("{}", str(N))),
    caption: [АЧХ фильтра первого порядка с $T=#T$]
  )
  #figure(
    image200("../fig/1/1/T/func/{}.png".replace("{}", str(N))),
    caption: [Сравнение иходного и фильтрованного сигнала при $T=#T$]
  )
]

По графикам видно,
что временной параметр $T$ влияет на плавность фильтрованного
сигнала. Слишком маленькое значение не фильрует белый шум 
на достаточном уровне, а слишком большое значение $T$ меняет форму
сигнала, помимо удаления шумов. 

Получили наилучший результат при $T=0.01$.

// === Вариация параметра $a$

Теперь исследуем на что влияет параметр $a$

#for (N, a) in (3, 4, 5).zip((1,2,3)) [
  #figure(
    image200("../fig/1/1/a/{}.png".replace("{}", str(N))),
    caption: [Сравнение иходного и фильтрованного сигнала при $a=#a$]
  )
]

При постоянном параметре $T$ белый шум проще удалить, если его амплитуда 
меньше амплитуды сигнала $a$ и сложнее удалить, если величина шума $b >= a$.

// === Проверка теоремы о свёртке

Попробовали получить такой же результат, как и фильтрованный сигнал, умножив 
передаточную функцию $W_1(i omega)$ на Фурье-образ зашумленного сигнала. Частоты
далекие от нуля на АЧХ после произведения уменьшились. Полученный таким образом сигнал полностью совпал с фильтрованным сигналом.

// === Сравнение Фурье-образов

Теперь сравним Фурье-образы зашумленного, исходного и 
фильтрованного сигналов, чтобы увидеть как фильтр влияет на 
разные частоты.

#figure(
  image200("../fig/1/1/comp/2.png"),
  caption: [Сравнение образов сигналов при линейной фильрации первого порядка]
)

Образ фильтрованного сигнала можно объяснить видом АЧХ фильтра:
частоты, далекие от нуля подавляются, а близкие к нулю 
остаются почти не тронутыми. Фильтр эффективно работает для
сигнала $g(t)$, потому что основные частоты квадратной волны
находятся в диапзоне частот близком к нулю.

// === Сравнение образов фильтрованного сигнала и произведения сигнала и передаточной функции

Убедимся в том, что произведение передаточной функции на 
образ зашумленного сигнала даёт такой же результат, как и
образ фильтрованного сигнала фильтром с такой передаточной функцией,
построив два графика образов на одном рисунке.

#figure(
  image200("../fig/1/1/comp/3.png"),

)

Графики совпали, как и ожидалось.


// TASK 1.2
== Фильтр второго порядка

Возьмем подобный зашумленный сигнал $u(t)$, но примем $b=0$.
Такой сигнал имеет только периодический шум, частота которого
зависит от $d$, а точнее, шум будет на частоте $2pi d$.

Рассмотрим линейный фильтр второго порядка вида
$
  W_2 (p) = (p^2 + a_1 p + a_2) / (p^2 + b_1 p + b_2)
$
Наша задача подобрать такие коэффициенты $a_1, a_2,b_1,b_2$, чтобы:
- #[
  Фильтр был _устойчивым_: у полинома знаменателя веществанная часть 
должна быть строго отрицательная.]
- #[
  АЧХ фильтра должна быть равна 1 на нулевых частотах и при $omega arrow.r.long infinity$.
]
- #[
  Для некоторой частоты $omega_0$ АЧХ фильтра должна быть равна нулю.
]

Пока можем выдвинуть гипотезу, что $omega_0$ должна совпасть с частотой шума.
Так как именно эта частота на АЧХ равна нулю, после произведения она исчезнет из образа
сигнала и в фильтрованном сигнале после обратного преобразования Фурье.
 То есть такой фильтр должен
удалять определенную частоту $omega_0$ или ее окрестность, не затрагивая
остальной спектр. Проверим как влияет изменение $omega_0$ на результат далее.


Фильтр с такими характеристиками называется 
_Полосно-заграждающий (band-stop)_, с передаточной функцией вида

$
  (p^2 + omega_0 ^ 2 )/ (p^2 + omega_c p + omega_0^2)
$

Построим АЧХ Такого фильтра

#figure(
  image200("../fig/1/2/b1/0.png"),
  caption: [АЧХ фильтра второго порядка]
)

По рисунку видно, что у этого конкретного фильтра 
заграждаемая частота --- 20~Гц.

Рассморим влияние параметра $b_1 = omega_c$ на АЧХ 
и результат фильтрации


#for (N, b1) in (("0": 100, "3": 500, "6": 1000)) [
  #align(left, $b_1 = #b1$)

  #figure(
    image200("../fig/1/2/b1/{N}.png".replace("{N}", str(N))),
    caption: [АЧХ фильтра второго порядка при $b_1 = #b1$]
  )

  #figure(
    image200("../fig/1/2/b1/{N}.png".replace("{N}", str(int(N)+1))),
    caption: [Результат фильтрации при $b_1 = #b1$]
  )

  #figure(
    image200("../fig/1/2/b1/{N}.png".replace("{N}", str(int(N)+2))),
    caption: [Сравнение образов зашумленного и фильтрованного сигналов \ при $b_1 = #b1$]
  )
]

Сравнив Графики АЧХ рассмотренных конкретных фильтров
с разным значением параметра $b_1 = w_c$ видим, что он 
отвечает за ширину заграждаемого окна. Для
рассматриемого зашумленного сигнала наилучшим стало значение
$b_1 = 100$.

На всех предыдущих рисунках был рассмотрен случай $d=omega_0$,
теперь рассмотрим как повлияет изменение $d$ на
результат фильтрации.

#for (d, N) in ("25": 0, "30": 2, "60": 4) [
  $d = 2pi times #d$
  #figure(
    image200("../fig/1/2/d/{N}.png".replace("{N}", str(N))),
    caption: [Сравнение зашумленного и фильтрованного сигнала при $d=2pi times #d$]
  )
  #figure(
  image200("../fig/1/2/d/{N}.png".replace("{N}", str(N+1))),
  caption: [Сравнение образов зашумленного и фильтрованного сигнала при $d=2pi times #d$]
  )
]

По рисункам видно, что чем больше разница $|d - omega_0|$, тем хуже
удаляется шум.

Сравним, также как в предыдущем задании, результат фильтрации с 
обратным преобразованием произведения $W_2(i omega)hat(u)(t)$

#figure(
  image200("../fig/1/2/comp/1.png"),
  caption: [Сравнение фильтрованного сигнала и обратного преобразования 
  произведения передаточной функции]
)

Графики совпадают почти на всей всем интервале $t$, но в окрестности 
точки $t=0$ образы сигналов, полученные двумя способами немного расходятся.
Это связано с тем, что динамическая фильтрация в момент времени $t=0$ выходит
из состояния покоя. Это занимает некоторое время и в результате в сигнале
появляется затухающая #quote[переходная] компонента, когда как при умножении
образа функции на передаточную функцию фильтра она не возникает.

#figure(
  image200("../fig/1/2/comp/2.png"),
  caption: [Сравнение образов чистого, зашумленного и фильтрованного сигналов]
)

#figure(
  image200("../fig/1/2/comp/3.png"),
  caption: [Сравнение образов фильтрованного сигнала и 
  произведения передаточной функции]
)

Образы сигналов после динамической фильтрации и после произведения
передаточной функции на образ зашумленного сигнала снова совпали.

= Задание 2. Фильтрация биржевых данных

В этом задании воспользуемся линейным фильтром первого порядка и
попробуем сгладить реальные данные. В качестве исходных данных
нам было предложено использовать цену акция компании ПАО Сбербанк,
но решили использовать _стоимость криптовалюты BTC_ 
#footnote()[
  https://www.kaggle.com/datasets/swaptr/bitcoin-historical-data
]
за период с ее появления до 2023-02-21T00:33.



#let _labels = (
[Стоимость BTC с 2016-09-09 по 2023-06-13],
[Стоимость BTC с 2019-01-01 по 2022-01-01],
[Стоимость BTC с 2021-01-01 по 2021-07-01],
)
#for N in (1,2,3) [
  #figure(
    image200("../fig/2/{N}.png".replace("{N}", str(N))),
    caption: _labels.at(N - 1)
  )
]

Нетрудно заметить, что чем больше взятый период $T$, тем плавнее
получается график и тем медленнее он отвечает на изменение входных
данных. Подобная фильтрация часто встречается в финансовых инструментах и
называется _moving average_ и позволяет получить больше информации
о наборе данных.


#pagebreak()

= Листинги
Ниже представлен исходный код Jupyter блокнота со
всеми заданиями лабораторной работы, разбитый
на листинги по ячейкам

#for X in range(1, 21) [
  #show figure: set block(breakable: true)
  #figure(
    align(left, raw(
      read(
        "../python/cells/cell_{x}.py"
          .replace("{x}", str(X))
      ),
      lang: "py"
    )
  ), caption: []
  )
  #v(1em)
]
